# network-computing
the homework of network computing class
---

## 上机报告

### 上机题目及上机内容

### 小组名单以及各自工作内容

### 协议设计

##### 客户端如何定位服务器

客户端固定域名，使用域名解析得到的 IP 来定位服务器，服务端使用固定端口号 4000。

##### 协议格式

基于 TCP 的应用层协议。TCP 是基于点到点的可靠的传输层协议，无需考虑应用层协议的一致性问题。采用基于 Key-Value 模式的 JSON 数据格式实现。		  基于 TCP 的应用层协议。TCP 是基于点到点的可靠的传输层协议，无需考虑应用层协议的一致性问题。采用基于 Key-Value 模式的 JSON 数据格式实现。
		  
###### 登录

客户端请求参数:

| 参数       | 意义    | 备注      |
| -------- | ----- | ------- |
| type     | 协议类型  | 值为 "00" |
| bankcard | 银行卡号  |         |
| password | 银行卡密码 |         |

服务端返回参数:

| 参数         | 意义             | 备注            |
| ---------- | -------------- | ------------- |
| type       | 协议类型           | 值为 "00"       |
| status     | 状态标志           | 0 代表成功，1 代表失败 |
| token      | 会话标识           |               |
| expiration | 到期时间           |               |
| msg        | 错误消息，仅失败的时候不为空 |               |

大致流程:

1. 客户端使用银行卡号与密码请求登录
2. 服务端收到请求后，验证银行卡号与密码
3. 验证成功后，服务端会签发一个 token，再把这个 token 发送给客户端；若验证失败，则返回错误原因
4. 客户端收到 token 后把它存储起来，每次向服务端请求资源的时候带着服务端签发的 token
5. 服务端收到请求后，验证客户端请求里面的 token
6. 服务端返回消息时，也会带上 token

关于参数 token:

* 每次打开客户端，都会发起登录请求，获取新的 token
* 因客户端崩溃导致 token 的存在，客户端登录成功后覆盖之
* 关闭客户端，即删除当前的 token

关于参数 expiration:

* 初始值为一天(86400秒)，每秒减 1
* 值为 300 的时候，客户端发起**续期**请求
* 值为 0 的时候，token 无效，服务端删除该值

示例:

```json
/* Client 请求格式 */
{
    "type": "00",
    "bankcard": "0123456789",
    "password": "0123456789"
}

/* Server 返回格式 */
{
    "type": "01",
    "status": "0",
    "token": "1995172d456c6f0266142f8175eaafca",
    "expiration": "86400",
    "msg": ""
}
```

###### 续期

客户端请求参数:

| 参数       | 意义   | 备注    |
| -------- | ---- | ----- |
| type     | 协议类型 | 值为 10 |
| token    | 会话标识 |       |
| bankcard | 银行卡号 |       |

服务端返回参数:

| 参数     | 意义             | 备注            |
| ------ | -------------- | ------------- |
| type   | 协议类型           | 值为 11         |
| token  | 会话标识           |               |
| status | 状态标志           | 0 代表成功，1 代表失败 |
| msg    | 错误消息，仅失败的时候不为空 |               |

大致流程:

1. expiration 值为 300 的时候，客户端发起续期请求
2. 服务端接收到该请求后，设置这 token 的 expiration 为 86400，同时返回给服务端成功状态
3. 服务端接收到请求后，设置 expiration 为 86400

示例:

```json
/* Client 请求格式 */
{
    "type": "10",
    "token": "1995172d456c6f0266142f8175eaafca",
    "bankcard": "0123456789"
}

/* Server 返回格式 */
{
    "type": "11",
    "token": "1995172d456c6f0266142f8175eaafca",
    "status": "0",
    "msg": ""
}
```

###### 存款

客户端请求参数:

| 参数       | 意义   | 备注    |
| -------- | ---- | ----- |
| type     | 协议类型 | 值为 20 |
| token    | 会话标识 |       |
| bankcard | 银行卡号 |       |
| amount   | 金额   |       |

服务端返回参数:

| 参数     | 意义             | 备注            |
| ------ | -------------- | ------------- |
| type   | 协议类型           | 值为 21         |
| token  | 会话标识           |               |
| status | 状态标志           | 0 代表成功，1 代表失败 |
| msg    | 错误消息，仅失败的时候不为空 |               |

大致流程:

1. 客户端发起存款请求
2. 服务端验证账户是否有效
3. ...

示例:

```json
/* Client 请求格式 */
{
    "type": "20",
    "token": "1995172d456c6f0266142f8175eaafca",
    "bankcard": "0123456789",
    "amount": "100"
}

/* Server 返回格式 */
{
    "type": "21",
    "token": "1995172d456c6f0266142f8175eaafca",
    "status": "0",
    "msg": ""
}
```

###### 取款

客户端请求参数:

| 参数       | 意义   | 备注    |
| -------- | ---- | ----- |
| type     | 协议类型 | 值为 30 |
| token    | 会话标识 |       |
| bankcard | 银行卡号 |       |
| amount   | 金额   |       |

服务端返回参数:

| 参数     | 意义             | 备注            |
| ------ | -------------- | ------------- |
| type   | 协议类型           | 值为 31         |
| token  | 会话标识           |               |
| status | 状态标志           | 0 代表成功，1 代表失败 |
| msg    | 错误消息，仅失败的时候不为空 |               |

大致流程:

1. 客户端发起存款请求
2. 服务端验证账户是否有效
3. ...

示例:

```json
/* Client 请求格式 */
{
    "type": "30",
    "token": "1995172d456c6f0266142f8175eaafca",
    "bankcard": "0123456789",
    "amount": "100"
}

/* Server 返回格式 */
{
    "type": "31",
    "token": "1995172d456c6f0266142f8175eaafca",
    "status": "0",
    "msg": ""
}
```

###### 转账

客户端请求参数:

| 参数          | 意义        | 备注    |
| ----------- | --------- | ----- |
| type        | 协议类型      | 值为 40 |
| token       | 会话标识      |       |
| bankcard    | 银行卡号      |       |
| transferred | 转入账户的银行卡号 |       |
| amount      | 金额        |       |

服务端返回参数:

| 参数     | 意义             | 备注            |
| ------ | -------------- | ------------- |
| type   | 协议类型           | 值为 41         |
| token  | 会话标识           |               |
| status | 状态标志           | 0 代表成功，1 代表失败 |
| msg    | 错误消息，仅失败的时候不为空 |               |

大致流程:

1. 客户端发起存款请求
2. 服务端验证账户是否有效
3. ...

示例:

```json
/* Client 请求格式 */
{
    "type": "40",
    "token": "1995172d456c6f0266142f8175eaafca",
    "bankcard": "0123456789",
    "transferred": "1234567890",
    "amount": "100"
}

/* Server 返回格式 */
{
    "type": "41",
    "token": "1995172d456c6f0266142f8175eaafca",
    "status": "0",
    "msg": ""
}
```


### 上机题目完成过程中碰到的问题

1. 事务操作中客户端或服务端崩溃了怎么办？

这是 CAP 理论中的一致性（Consistency）问题，解决这类问题的协议和算法中，比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。

在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足 ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该 commit 还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。

打算使用二阶段协议解决事务操作中客户端或服务端崩溃的情况。二阶段提交主要保证了分布式事务的原子性，即所有节点要么全做要么全不做。

**无法做到最终一致性**

#### 二阶段提交

所谓的两个阶段是指：
* 第一阶段——准备阶段（投票阶段）
* 第二阶段——提交阶段（执行阶段）

##### 前提

二阶段提交算法的成立基于以下假设：
* 该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。
* 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
* 所有节点不会永久性损坏，即使损坏后仍然可以恢复

##### 准备阶段

事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。

三个步骤：
1. 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
2. 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。

##### 提交阶段

如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

两种情况。

###### 当协调者节点从所有参与者节点获得的相应消息都为”同意”时:

![成功](/asserts/success.png)

1. 协调者节点向所有参与者节点发出”正式提交(commit)”的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送”完成”消息。
4. 协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

###### 如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时:

![失败](/asserts/fail.png)

1. 协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送”回滚完成”消息。
4. 协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。

不管结果如何，第二阶段都会结束当前事务。

##### 结果

二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：

* 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
* 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
* 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
* 二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

##### 具体实现

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | |

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 是否正常执行 |

第一阶段提交:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| msg | JSON 数据 | 所执行的操作 |

第一阶段返回结果:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 执行结果 | |

第二阶段提交:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 0 代表执行，1 代表回滚 |

第二阶段返回结果:
| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 执行结果 | |

### 上机题目最终测试报告

### 思考题

* 帐号路由功能的实现
* 交叉互连（与其他小组开发的模拟系统连接）的结果预估
* 应用层协议的作用
* 对 C/S 计算模式的认识
* 对课程内容设置、讲授方式及教师课堂讲解的意见和建议

