ATM request --> Coordinator
                      |
           1          v
                 Transaction
ATM recv <-- First stage start     --> Server recv
2|                                        |
 | local transaction                      | local transaction
 |                                        |
3v                                        v
ATM send --> First stage complete  <-- Server send
                     |
          4          v
ATM recv <-- Second stage start    --> Server recv
5|                                        |
 | complete                               | complete
6v        7                               v
ATM send --> Second stage complete <-- Server send

# 崩溃时间段

1 -- 请求发送之后，收到协调者询问之前
2 -- 收到协调者询问之后，执行本地事务之前
3 -- 执行本地事务之后，发送 ACK 之前，收到协调者确认之前
4 -- 收到协调者确认之后，释放本地事务资源之前
5 -- 释放本地事务资源后，发送 ACK 之前
6 -- 发送 ACK 之后

假定：本地事务一定可以执行成功(失败后可以根据日志回滚)，代码会正常运行
因此，分布式事务只可能在 send / rece 处出现问题

二阶段提交协议

因协调者的存在，只要第一阶段结束，协调者未收到执行成功的确认(或__超时未收到消息__)，参与者都能够保证一致性。

参与者收到第二阶段确认前宕机(弊端：数据不一致)
参与者执行 commit 时候宕机 -- 协调者收到所有参与者节点反馈的 完成 消息之后，才完成事务
发送消息之后宕机 ... 事务已经完成

弊端：
同步阻塞问题。__执行过程中，所有参与者都是事务阻塞型的__。
单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
数据不一致。网络故障或协调者宕机导致只有一部分参与者收到 commit 请求，收到 commit 请求的参与者会执行 commit 操作，但其他未收到 commit 请求的机器无法执行操作.

无法解决的问题：
协调者发送 commit 之后宕机，唯一接收到这条消息的参与者也宕机了，事务变得不确定。

__假设协调者正常，网络正常，第一阶段 ACK 后第二阶段 RECV 前正常__

## ATM 机 / Server 崩溃

应对策略：
根据日志确定执行到了哪一阶段 --
  第一阶段 ACK 完成前，回滚
  第一阶段 ACK 完成后、第二阶段 RECV 前，不存在该情况(假设)
  第二阶段 RECV 后，继续执行，直至释放资源，发送 ACK(假设协调者正常)

系统如何满足用户在业务功能实现后必须拿到交易清单情况:
日志的存在，可以保证后续如何进行

用户等待：
协调者正常工作，服务器崩溃不影响。
