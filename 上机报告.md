# ATM机模拟系统上机报告
## 小组名单及各自工作

## 协议设计
### 客户端如何定位服务器
客户端静态绑定服务器的IP与PORT,由于客户端与服务端中间加入了一个协调者（下文会提到），因此客户端实际上绑定的是协调者的地址与端口。
### 请求与响应流程的详细步骤
**客户端向服务器发送请求及得到结果的整个流程的详细步骤**

具体的操作有登录，取款，存款，转账：

#### 登录：
1. 客户端使用银行卡号与密码请求登录
2. 服务端收到请求后，验证银行卡号与密码
3. 验证成功后，服务端会签发一个 token，再把这个 token 发送给客户端；若验证失败，则返回错误原因
4. 客户端收到 token 后把它存储起来，每次向服务端请求资源的时候带着服务端签发的 token
5. 服务端收到请求后，验证客户端请求里面的 token
6. 服务端返回消息时，也会带上 token

关于参数 token:

* 每次打开客户端，都会发起登录请求，获取新的 token
* 因客户端崩溃导致 token 的存在，客户端登录成功后覆盖之
* 关闭客户端，即删除当前的 token

关于参数 deadline:

* 初始值为当前时间+一天(86400秒)
* 当前时间与 deadline 相差 300 的时候，客户端发起**续期**请求
* 当前时间大于等于 deadline 的时候，token 无效，服务端删除该值

其余操作详细过程类似

### 数据包的结构内容和解析方法
基于 TCP 的应用层协议。TCP 是基于点到点的可靠的传输层协议，无需考虑应用层协议的一致性问题。采用基于 Key-Value 模式的 JSON 数据格式实现。JSON有其固定的解析方式，大大简化了解析的工作。具体的数据结构实例在下文应用层实例中。
### 系统崩溃策略

使用**二阶段提交协议**解决事务操作中客户端或服务端崩溃的情况。二阶段提交主要保证了分布式事务的原子性，即所有节点要么全做要么全不做。

#### 基于以下假设:
* 该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。
* 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
* 所有节点不会永久性损坏，即使损坏后仍然可以恢复

#### 客户端与服务端二阶段提交协议具体步骤如下:
```
ATM request --> Coordinator
                      |
                      v
                 Transaction
ATM recv <-- First stage start     --> Server recv
 |                                        |
 | local transaction                      | local transaction
 |                                        |
 v                                        v
ATM send --> First stage complete  <-- Server send
                     |
                     v
ATM recv <-- Second stage start    --> Server recv
 |                                        |
 | complete                               | complete
 v                                        v
ATM send --> Second stage complete <-- Server send
```
**数据包格式如下:**

第一阶段提交:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| msg | JSON 数据 | 所执行的操作 |

第一阶段返回结果:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 执行结果 | |

第二阶段提交:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 0 代表执行，1 代表回滚 |

第二阶段返回结果:

| 参数 | 意义 | 备注 |
| ---- | ---- | ---- |
| sequence | 事务序列号 | |
| status | 状态 | 执行结果 | |
#### 考虑系统崩溃的时间段

ATM

1. 业务请求发送前
2. 业务请求发送之后，收到协调者询问之前
3. 收到协调者询问之后，发送 ACK 之前
4. 发送 ACK 之后，收到协调者确认之前
5. 收到协调者确认之后，发送 ACK 之前
6. 发送 ACK 之后，收到结果前
7. 收到结果后

Server

1. 收到协调者询问之前
2. 收到协调者询问之后，发送 ACK 之前
3. 发送 ACK 之后，收到协调者确认之前
4. 收到协调者确认之后，发送 ACK 之前
5. 发送 ACK 之后

假定：本地事务一定可以执行成功(失败后可以根据日志回滚)，代码会正常运行；因此，分布式事务只可能在 send / rece 处出现问题

因协调者的存在，只要第一阶段结束，协调者未收到执行成功的确认(或__超时未收到消息__)，参与者都能够保证一致性。

参与者收到第二阶段确认前宕机(弊端：数据不一致)
参与者执行 commit 时候宕机 -- 协调者收到所有参与者节点反馈的 完成 消息之后，才完成事务
发送消息之后宕机 ... 事务已经完成

弊端：
1. 同步阻塞问题。__执行过程中，所有参与者都是事务阻塞型的__。
2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
3. 数据不一致。网络故障或协调者宕机导致只有一部分参与者收到 commit 请求，收到 commit 请求的参与者会执行 commit 操作，但其他未收到 commit 请求的机器无法执行操作.

无法解决的问题：
* 协调者发送 commit 之后宕机，唯一接收到这条消息的参与者也宕机了，事务变得不确定。

__假设协调者正常，网络正常，第一阶段 ACK 后第二阶段 RECV 前正常__

> 未实现 协调者收到所有参与者节点反馈的 完成 消息之后，才完成事务。
>   实现: 默认第二阶段中参与者一定会执行完操作

#### ATM 机 / Server 崩溃

应对策略： 根据日志确定执行到了哪一阶段
* 第一阶段 ACK 完成前，回滚
* 第一阶段 ACK 完成后、第二阶段 RECV 前，不存在该情况(假设)
* 第二阶段 RECV 后，继续执行，直至释放资源，发送 ACK(假设协调者正常)


* 系统如何满足用户在业务功能实现后必须拿到交易清单情况:
* 日志的存在，可以保证后续如何进行

* 用户等待：
* 协调者正常工作，服务器崩溃不影响。

### 应用层协议示例

**请求与响应数据包中的json数据**

这里列出与转账的示例，其余类似。
#### 登录

客户端请求参数:

| 参数       | 意义    | 备注      |
| -------- | ----- | ------- |
| type     | 协议类型  | 值为 00 |
| bankcard | 银行卡号  |         |
| password | 银行卡密码 |         |

服务端返回参数:

| 参数         | 意义             | 备注            |
| ---------- | -------------- | ------------- |
| type       | 协议类型           | 值为 01       |
| status     | 状态标志           | 0 代表成功，1 代表失败 |
| token      | 会话标识           |               |
| deadline | 到期时间           |               |
| msg        | 消息 |               |
```json
/* Client 请求格式 */
{
    "type": 00,
    "bankcard": "0123456789",
    "password": "0123456789"
}

/* Server 返回格式 */
{
    "type": 01,
    "status": 0,
    "token": "1995172d456c6f0266142f8175eaafca",
    "deadline": "1491567752",
    "msg": ""
}
```
###### 转账

客户端请求参数:

| 参数          | 意义        | 备注    |
| ----------- | --------- | ----- |
| type        | 协议类型      | 值为 40 |
| token       | 会话标识      |       |
| bankcard    | 银行卡号      |       |
| transferred | 转入账户的银行卡号 |       |
| amount      | 金额        |       |

服务端返回参数:

| 参数     | 意义             | 备注            |
| ------ | -------------- | ------------- |
| type   | 协议类型           | 值为 41         |
| token  | 会话标识           |               |
| status | 状态标志           | 0 代表成功，1 代表失败 |
| msg    | 消息 |               |

大致流程:

1. 客户端发起存款请求
2. 服务端验证账户是否有效
3. ...

示例:

```json
/* Client 请求格式 */
{
    "type": 40,
    "token": "1995172d456c6f0266142f8175eaafca",
    "bankcard": "0123456789",
    "transferred": "1234567890",
    "amount": 100
}

/* Server 返回格式 */
{
    "type": 41,
    "token": "1995172d456c6f0266142f8175eaafca",
    "status": 0,
    "msg": ""
}
```
## 遇到的问题及解决方案
1. 事务操作中客户端或服务端崩溃了怎么办？

这是 CAP 理论中的一致性（Consistency）问题，解决这类问题的协议和算法中，比较著名的有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和Paxos算法。

在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足 ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该 commit 还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。

打算使用二阶段协议解决事务操作中客户端或服务端崩溃的情况。二阶段提交主要保证了分布式事务的原子性，即所有节点要么全做要么全不做。

**无法做到最终一致性**

### 二阶段提交

所谓的两个阶段是指：
* 第一阶段——准备阶段（投票阶段）
* 第二阶段——提交阶段（执行阶段）

#### 前提

二阶段提交算法的成立基于以下假设：
* 该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。
* 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
* 所有节点不会永久性损坏，即使损坏后仍然可以恢复

#### 准备阶段

事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。

三个步骤：
1. 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
2. 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。

#### 提交阶段

如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

两种情况。

##### 当协调者节点从所有参与者节点获得的相应消息都为”同意”时:

![成功](/asserts/success.png)

1. 协调者节点向所有参与者节点发出”正式提交(commit)”的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送”完成”消息。
4. 协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

##### 如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时:

![失败](/asserts/fail.png)

1. 协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送”回滚完成”消息。
4. 协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。

不管结果如何，第二阶段都会结束当前事务。

##### 结果

二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：

* 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
* 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
* 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
* 二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
## 测试结果
## 思考题
### 帐号路由
针对不同地区（异地支取、存储）、不同银行（跨行支取、存储）的业务，其后台用户业务数据存储可能并非由与ATM机直连的银行业务系统负责管理，需将该请求转发至负责管理的银行业务系统

#### 策略：

**ATM机只将请求数据包发往与其绑定的协调者，所有路由识别与转发皆由协调者实现。**
#### 如何识别账号所属银行系统？
协调者首先根据卡号的前6位数字代表发卡行标识代码，也叫BIN号，不同的BIN号代表了不同的银行卡组织和卡片级别，判断此帐号属于哪家银行（此处默认同一银行的数据库一致）
1. 对于同一银行的异地支取、存储业务，协调者可通过银行卡号，查询帐号归属地数据库，并将请求转发到负责该卡的协调者。
2. 对于跨行的支取业务，协调者调用其他银行的应用层协议API或者其，将数据转化成相应银行的数据包。
#### 负责管理的银行业务系统在处理完毕后，如何返回处理结果？
应按照发送数据包的顺序原路逆向返回，协调者提供一个即时路由表，记录所有接收的转发数据包的上一个源与目的地，完成转发的所有步骤后将其删除
### 交叉互联结果预测
预测是可行的。只需要其他开发小组提供其应用层协议即可单独在协调者中加入此转发功能，将数据请求包发往其他小组开发的银行系统，但无法保证系统崩溃时的处理策略，因为本系统在应用层协议的基础上增加了二阶段提交，与其他系统的服务器逻辑不一致。
### 应用层协议作用
对于不同的系统其数据库存储方式和服务逻辑可能不一致，但事务是一样的，只需要提供相同的应用层协议便可将同类型的不同的系统互联。
### 对 *C/S* 计算模式的认识
1. 应用服务器运行数据负荷较轻。
最简单的C/S体系结构的数据库应用由两部分组成，即客户应用程序和数据库服务器程序。二者可分别称为前台程序与后台程序。运行数据库服务器程序的机器，也称为应用服务器。一旦服务器程序被启动，就随时等待响应客户程序发来的请求；客户应用程序运行在用户自己的电脑上，对应于数据库服务器，可称为客户电脑，当需要对数据库中的数据进行任何操作时，客户程序就自动地寻找服务器程序，并向其发出请求，服务器程序根据预定的规则作出应答，送回结果，应用服务器运行数据负荷较轻。
2. 数据的储存管理功能较为透明。
在数据库应用中，数据的储存管理功能，是由服务器程序和客户应用程序分别独立进行的，前台应用可以违反的规则，并且通常把那些不同的（不管是已知还是未知的）运行数据，在服务器程序中不集中实现，例如访问者的权限，编号可以重复、必须有客户才能建立定单这样的规则。所有这些，对于工作在前台程序上的最终用户，是“透明”的，他们无须过问（通常也无法干涉）背后的过程，就可以完成自己的一切工作。在客户服务器架构的应用中，前台程序不是非常“瘦小”，麻烦的事情都交给了服务器和网络。在C/S体系的下，数据库不能真正成为公共、专业化的仓库，它受到独立的专门管理。
3. C/S架构的劣势是高昂的维护成本且投资大。
首先，采用C/S架构，要选择适当的数据库平台来实现数据库数据的真正“统一”，使分布于两地的数据同步完全交由数据库系统去管理，但逻辑上两地的操作者要直接访问同一个数据库才能有效实现，有这样一些问题，如果需要建立“实时”的数据同步，就必须在两地间建立实时的通讯连接，保持两地的数据库服务器在线运行，网络管理工作人员既要对服务器维护管理，又要对客户端维护和管理，这需要高昂的投资和复杂的技术支持，维护成本很高，维护任务量大。
其次，传统的C/S结构的软件需要针对不同的操作系统系统开发不同版本的软件，由于产品的更新换代十分快，代价高和低效率已经不适应工作需要。在JAVA这样的跨平台语言出现之后，B/S架构更是猛烈冲击C/S，并对其形成威胁和挑战。
### 意见和建议
